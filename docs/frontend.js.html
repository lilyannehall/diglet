<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>frontend.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Diglet.html">Diglet</a><ul class='methods'><li data-type='method'><a href="Diglet.html#close">close</a></li><li data-type='method'><a href="Diglet.html#listen">listen</a></li></ul></li><li><a href="Frontend.html">Frontend</a></li><li><a href="Handshake.html">Handshake</a><ul class='methods'><li data-type='method'><a href="Handshake.html#sign">sign</a></li><li data-type='method'><a href="Handshake.html#toBuffer">toBuffer</a></li><li data-type='method'><a href="Handshake.html#verify">verify</a></li><li data-type='method'><a href="Handshake.html#.challenge">challenge</a></li></ul></li><li><a href="Proxy.html">Proxy</a><ul class='methods'><li data-type='method'><a href="Proxy.html#clean">clean</a></li><li data-type='method'><a href="Proxy.html#pop">pop</a></li><li data-type='method'><a href="Proxy.html#push">push</a></li></ul></li><li><a href="Server.html">Server</a><ul class='methods'><li data-type='method'><a href="Server.html#getProxyInfoById">getProxyInfoById</a></li><li data-type='method'><a href="Server.html#listen">listen</a></li><li data-type='method'><a href="Server.html#routeHttpRequest">routeHttpRequest</a></li><li data-type='method'><a href="Server.html#routeWebSocketConnection">routeWebSocketConnection</a></li></ul></li><li><a href="Tunnel.html">Tunnel</a><ul class='methods'><li data-type='method'><a href="Tunnel.html#close">close</a></li><li data-type='method'><a href="Tunnel.html#open">open</a></li><li data-type='method'><a href="Tunnel.html#queryProxyInfoFromServer">queryProxyInfoFromServer</a></li><li data-type='method'><a href="Tunnel.html#reconnect">reconnect</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">frontend.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const { HSTS_POLICY_HEADER } = require('./server');
const path = require('path');
const express = require('express');
const serveStatic = require('serve-static');
const pkg = require('../package');
const merge = require('merge');
const tld = require('tldjs');
const http = require('http');
const https = require('https');
const { EventEmitter } = require('events');

/**
 * Frontend application that provides an interface to route incoming
 * connections
 */
class Frontend extends EventEmitter {

  static get DEFAULTS() {
    return {
      tlsCredentials: { key: null, cert: null }
    };
  }

  /**
   * @constructor
   */
  constructor(options){
    super();
    this._opts = this._checkOptions(merge(Frontend.DEFAULTS, options));
    this._credentials = this._opts.tlsCredentials;
    this._started = Date.now();
    this._app = express();

    this._bootstrap();
  }

  /**
   * @private
   */
  _bootstrap() {
    this._app.set('view engine', 'pug');
    this._app.set('views', path.join(__dirname, '../web/views'));
    this._app.use(serveStatic(path.join(__dirname, '../web/static')));
    this._app.use(this.handleServerRequest.bind(this));
    this._app.get('/', this._serveRoot.bind(this));
    this._app.get('/:id', this._serveTunnelInfo.bind(this));
    this._app.use((req, res) => this._serveMissing(req, res));
    this._app.use((err, req, res, next) =>
      this._serveError(err, req, res, next));
  }

  /**
   * @private
   */
  _serveRoot(request, response) {
    const locals = {
      version: pkg.version,
      started: this._started
    };

    response.format({
      html: () => response.render('landing', locals),
      json: () => response.json(locals)
    });
  }

  /**
   * @private
   */
  _serveTunnelInfo(request, response, next) {
    const proxy = request.params.id;

    this.emit('PROXY_QUERY', {
      proxy,
      queryHandler(info) {
        if (!info) {
          const err = new Error(
            `Our server moles could not find info on the tunnel "${proxy}".`
          );
          err.code = 404;
          return next(err);
        }

        response.format({
          html: () => response.render('info', info),
          json: () => response.json(info)
        });
      }
    });
  }

  /**
   * @private
   */
  _serveMissing(request, response) {
    const error = {
      code: 404,
      message: 'Our server moles could not find that resource.'
    };
    this._serveMissingOrError(error, request, response);
  }

  /**
   * @private
   */
  _serveError(error, request, response, next) {
    if (!error) {
      return next();
    }
    error.code = 500;
    this._serveMissingOrError(error, request, response);
  }

  /**
   * @private
   */
  _serveMissingOrError(error, request, response) {
    const code = error.code || 500;

    response.append('Strict-Transport-Security', HSTS_POLICY_HEADER);
    response.status(code);
    response.format({
      html: () => response.render('error', { code, message: error.message }),
      json: () => response.json({ code, message: error.message })
    });
    response.connection.destroy();
  }

  /**
   * @private
   */
  _checkOptions(o) {
    return o;
  }

  static getProxyIdFromSubdomain(request, hostname) {
    let subdomain = tld.getSubdomain(request.headers.host);
    let parts = subdomain ? subdomain.split('.') : [];

    if (request.headers.host === hostname) {
      return '';
    } else if (parts.length > 1) {
      return parts[0];
    } else {
      return subdomain;
    }
  }

  handleServerRequest(request, response, next) {
    let proxyId = Frontend.getProxyIdFromSubdomain(request,
      this._opts.hostname);

    if (!proxyId) {
      return next();
    }

    this.emit('INCOMING_HTTPS', { proxy: proxyId, request, response, next });
  }

  handleServerUpgrade(request, socket) {
    let proxyId = Frontend.getProxyIdFromSubdomain(request,
      this._opts.hostname);

    if (!proxyId) {
      return socket.destroy();
    }

    this.emit('INCOMING_WSS', { proxy: proxyId, request, socket });
  }

  listen() {
    this.proxy = https.createServer(this._credentials, this._app);

    this.proxy.on('upgrade', (req, sock) => {
      this.handleServerUpgrade(req, sock);
    });

    this.proxy.listen(...arguments);
  }

  redirect() {
    this.redirect = http.createServer(function(req, res) {
      res.writeHead(301, {
        Location: `https://${req.headers.host}${req.url}`
      });
      res.end();
    }).listen(...arguments);
  }

}

module.exports = Frontend;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a> on Sat Nov 09 2024 14:31:55 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
